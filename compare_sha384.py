#!/usr/bin/env python3
"""
SHA-384 Implementation Comparison Tool

Compares Python hashlib vs VHDL implementations using:
- NIST CAVP test vectors (known-good reference)
- Explicit boundary length tests
- Random test vectors
- Multi-block stress tests
- Optional OpenSSL cross-verification
"""

import hashlib
import os
import random
import subprocess
import sys
import argparse
import shutil
from pathlib import Path


# =============================================================================
# NIST CAVP Test Vectors (from FIPS 180-4 and CAVP)
# These are independent reference values - NOT generated by this script
# =============================================================================
NIST_TEST_VECTORS = [
    # (name, message_hex, expected_hash)
    # Source: https://www.di-mgt.com.au/sha_testvectors.html
    # Source: NIST CAVP ShortMsg and LongMsg test vectors

    # Empty string
    ("NIST_empty",
     "",
     "38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b"),

    # "abc"
    ("NIST_abc",
     "616263",
     "cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7"),

    # "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" (56 bytes)
    ("NIST_56bytes",
     "6162636462636465636465666465666765666768666768696768696a68696a6b696a6b6c6a6b6c6d6b6c6d6e6c6d6e6f6d6e6f706e6f7071",
     "3391fdddfc8dc7393707a65b1b4709397cf8b1d162af05abfe8f450de5f36bc6b0455a8520bc4e6f5fe95b1fe3c8452b"),

    # "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu" (112 bytes)
    ("NIST_112bytes",
     "61626364656667686263646566676869636465666768696a6465666768696a6b65666768696a6b6c666768696a6b6c6d6768696a6b6c6d6e68696a6b6c6d6e6f696a6b6c6d6e6f706a6b6c6d6e6f70716b6c6d6e6f7071726c6d6e6f707172736d6e6f70717273746e6f707172737475",
     "09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712fcc7c71a557e2db966c3e9fa91746039"),

    # One million 'a' characters (from NIST CAVP LongMsg)
    # Hash verified against multiple implementations
    ("NIST_1million_a",
     "GENERATE_1M_A",  # Special marker - generated at runtime
     "9d0e1809716474cb086e834e310a4a1ced149e9c00f248527972cec5704c2a5b07b8b3dc38ecc4ebae97ddd87f3d8985"),
]

# FIPS 180-4 K constants for SHA-384/512 (Table 4)
# These are the first 64 bits of the fractional parts of the cube roots of the first 80 primes
FIPS_K_CONSTANTS = [
    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
    0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
    0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
    0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
    0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
    0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
    0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
    0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
    0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
    0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
    0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
    0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
    0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
    0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817,
]

# FIPS 180-4 Initial Hash Values for SHA-384 (Section 5.3.4)
FIPS_H_INIT = [
    0xcbbb9d5dc1059ed8, 0x629a292a367cd507, 0x9159015a3070dd17, 0x152fecd8f70e5939,
    0x67332667ffc00b31, 0x8eb44a8768581511, 0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4,
]

# Boundary test lengths (critical edge cases for SHA-384 padding)
BOUNDARY_LENGTHS = [
    0,    # Empty
    1,    # Minimum non-empty
    55,   # Last byte before padding would overflow single block
    56,   # Exactly 448 bits - padding fits in same block
    64,   # Half block
    111,  # One byte before two-block boundary
    112,  # Padding spills to second block
    119,  # 7 bytes before block boundary
    127,  # One byte before exact block boundary
    128,  # Exactly one block (padding is entirely in second block)
    129,  # One byte into second block
    239,  # Edge case near 2-block boundary
    240,  # Two blocks worth of data
    256,  # Exactly two blocks (padding in third)
]


def sha384_python(data: bytes) -> str:
    """Compute SHA-384 using Python's hashlib."""
    return hashlib.sha384(data).hexdigest()


def sha384_openssl(data: bytes) -> str:
    """Compute SHA-384 using OpenSSL (alternative reference)."""
    if not shutil.which("openssl"):
        return None
    try:
        result = subprocess.run(
            ["openssl", "dgst", "-sha384"],
            input=data,
            capture_output=True,
            timeout=10
        )
        if result.returncode == 0:
            # Output format: "(stdin)= <hash>" or "SHA384(stdin)= <hash>"
            output = result.stdout.decode().strip()
            return output.split("= ")[-1].lower()
    except Exception:
        pass
    return None


def pad_message(data: bytes) -> bytes:
    """
    Pad message according to SHA-384 spec (FIPS 180-4 Section 5.1.2).

    Padding consists of:
    1. Append bit '1' (0x80 byte)
    2. Append zeros until length ≡ 896 (mod 1024) bits = 112 (mod 128) bytes
    3. Append 128-bit big-endian length (in bits)
    """
    msg_len = len(data)
    bit_len = msg_len * 8

    # Append 0x80
    padded = data + b'\x80'

    # Pad with zeros until 112 mod 128 bytes (896 mod 1024 bits)
    # This leaves room for the 16-byte (128-bit) length field
    while (len(padded) % 128) != 112:
        padded += b'\x00'

    # Append 128-bit length as big-endian
    # High 64 bits (always 0 for messages < 2^64 bits)
    padded += (0).to_bytes(8, 'big')
    # Low 64 bits
    padded += bit_len.to_bytes(8, 'big')

    assert len(padded) % 128 == 0, f"Padded length {len(padded)} not multiple of 128"
    return padded


def bytes_to_hex_words(data: bytes) -> list:
    """Convert bytes to list of 64-bit hex strings."""
    words = []
    for i in range(0, len(data), 8):
        word = int.from_bytes(data[i:i+8], 'big')
        words.append(f"{word:016x}")
    return words


def write_test_vectors(filepath: Path, test_cases: list):
    """Write test vectors file for VHDL - simple format, no comments."""
    with open(filepath, 'w') as f:
        # First line: number of tests
        f.write(f"{len(test_cases)}\n")

        for name, blocks, expected_hash in test_cases:
            # Number of blocks for this test
            f.write(f"{len(blocks)}\n")
            # 16 words per block
            for block in blocks:
                words = bytes_to_hex_words(block)
                for w in words:
                    f.write(f"{w}\n")
            # Expected hash (6 x 64-bit words)
            for i in range(0, 96, 16):
                f.write(f"{expected_hash[i:i+16]}\n")


def run_vhdl_test(project_dir: Path, impl: str) -> dict:
    """Run VHDL testbench and parse results."""
    if impl == "baseline":
        pkg = "sha384_pkg.vhd"
        design = "sha384.vhd"
        tb = "sha384_file_tb.vhd"
        entity = "sha384_file_tb"
    elif impl == "fast":
        pkg = "sha384_fast_pkg.vhd"
        design = "sha384_fast.vhd"
        tb = "sha384_fast_file_tb.vhd"
        entity = "sha384_fast_file_tb"
    elif impl == "fast8":
        pkg = "sha384_fast_pkg.vhd"
        design = "sha384_fast8.vhd"
        tb = "sha384_fast8_file_tb.vhd"
        entity = "sha384_fast8_file_tb"
    elif impl == "pipeline":
        pkg = "sha384_fast_pkg.vhd"
        design = "sha384_pipeline.vhd"
        tb = "sha384_pipeline_file_tb.vhd"
        entity = "sha384_pipeline_file_tb"
    elif impl == "multi":
        # Multi needs both pipeline and multi designs
        pkg = "sha384_fast_pkg.vhd"
        design = "sha384_pipeline.vhd"
        design2 = "sha384_multi.vhd"
        tb = "sha384_multi_file_tb.vhd"
        entity = "sha384_multi_file_tb"
        # Compile with extra design file
        cmd = ["nvc", "-a", pkg, design, design2, tb]
        result = subprocess.run(cmd, cwd=project_dir, capture_output=True, text=True)
        if result.returncode != 0:
            return {"error": f"Compile failed: {result.stderr}"}
        # Elaborate and run (skip normal compile below)
        cmd = ["nvc", "-e", entity]
        result = subprocess.run(cmd, cwd=project_dir, capture_output=True, text=True)
        if result.returncode != 0:
            return {"error": f"Elaborate failed: {result.stderr}"}
        cmd = ["nvc", "-r", entity]
        result = subprocess.run(cmd, cwd=project_dir, capture_output=True, text=True, timeout=120)
        output = result.stdout + result.stderr
        results = {"passed": 0, "failed": 0, "hashes": []}
        for line in output.split('\n'):
            if "PASS" in line:
                results["passed"] += 1
            elif "FAIL" in line:
                results["failed"] += 1
            elif "Hash:" in line:
                parts = line.split("Hash:")
                if len(parts) > 1:
                    results["hashes"].append(parts[1].strip().lower())
        return results
    else:
        return {"error": f"Unknown impl: {impl}"}

    # Compile
    cmd = ["nvc", "-a", pkg, design, tb]
    result = subprocess.run(cmd, cwd=project_dir, capture_output=True, text=True)
    if result.returncode != 0:
        return {"error": f"Compile failed: {result.stderr}"}

    # Elaborate
    cmd = ["nvc", "-e", entity]
    result = subprocess.run(cmd, cwd=project_dir, capture_output=True, text=True)
    if result.returncode != 0:
        return {"error": f"Elaborate failed: {result.stderr}"}

    # Run
    cmd = ["nvc", "-r", entity]
    result = subprocess.run(cmd, cwd=project_dir, capture_output=True, text=True, timeout=60)

    output = result.stdout + result.stderr

    # Parse results
    results = {"passed": 0, "failed": 0, "hashes": []}
    for line in output.split('\n'):
        if "PASS" in line:
            results["passed"] += 1
        elif "FAIL" in line:
            results["failed"] += 1
        elif "Hash:" in line:
            # Extract hash from line like "Hash: abcd1234..."
            parts = line.split("Hash:")
            if len(parts) > 1:
                results["hashes"].append(parts[1].strip().lower())

    return results


def verify_k_constants(project_dir: Path) -> bool:
    """Verify K constants in VHDL packages match FIPS 180-4."""
    print("\n" + "=" * 60)
    print("VERIFYING K CONSTANTS AGAINST FIPS 180-4")
    print("=" * 60)

    packages = [
        ("sha384_pkg.vhd", "baseline"),
        ("sha384_fast_pkg.vhd", "optimized"),
    ]

    all_ok = True
    for pkg_file, pkg_name in packages:
        pkg_path = project_dir / pkg_file
        if not pkg_path.exists():
            print(f"  WARNING: {pkg_file} not found")
            continue

        content = pkg_path.read_text()

        # Extract K constants from VHDL
        vhdl_k = []
        for line in content.split('\n'):
            # Look for hex constants like x"428a2f98d728ae22"
            import re
            matches = re.findall(r'x"([0-9a-fA-F]{16})"', line)
            # Skip H_INIT values (they're at the beginning)
            for m in matches:
                val = int(m, 16)
                if val not in FIPS_H_INIT:  # Not an H_INIT value
                    vhdl_k.append(val)

        # Compare first 80 values (K constants)
        if len(vhdl_k) < 80:
            print(f"  {pkg_name}: Found only {len(vhdl_k)} K constants (expected 80)")
            all_ok = False
            continue

        mismatches = []
        for i in range(80):
            if vhdl_k[i] != FIPS_K_CONSTANTS[i]:
                mismatches.append((i, vhdl_k[i], FIPS_K_CONSTANTS[i]))

        if mismatches:
            print(f"  {pkg_name}: {len(mismatches)} K constant mismatches!")
            for idx, got, exp in mismatches[:5]:
                print(f"    K[{idx}]: got {got:016x}, expected {exp:016x}")
            all_ok = False
        else:
            print(f"  {pkg_name}: All 80 K constants match FIPS 180-4 ✓")

    return all_ok


def verify_h_init(project_dir: Path) -> bool:
    """Verify initial hash values match FIPS 180-4."""
    print("\n" + "=" * 60)
    print("VERIFYING H_INIT CONSTANTS AGAINST FIPS 180-4")
    print("=" * 60)

    packages = [
        ("sha384_pkg.vhd", "baseline"),
        ("sha384_fast_pkg.vhd", "optimized"),
    ]

    all_ok = True
    expected_names = ["H0_INIT", "H1_INIT", "H2_INIT", "H3_INIT",
                      "H4_INIT", "H5_INIT", "H6_INIT", "H7_INIT"]

    for pkg_file, pkg_name in packages:
        pkg_path = project_dir / pkg_file
        if not pkg_path.exists():
            continue

        content = pkg_path.read_text()
        mismatches = []

        for i, h_name in enumerate(expected_names):
            import re
            pattern = rf'{h_name}\s*:\s*word64\s*:=\s*x"([0-9a-fA-F]+)"'
            match = re.search(pattern, content)
            if match:
                val = int(match.group(1), 16)
                if val != FIPS_H_INIT[i]:
                    mismatches.append((h_name, val, FIPS_H_INIT[i]))

        if mismatches:
            print(f"  {pkg_name}: {len(mismatches)} H_INIT mismatches!")
            for name, got, exp in mismatches:
                print(f"    {name}: got {got:016x}, expected {exp:016x}")
            all_ok = False
        else:
            print(f"  {pkg_name}: All 8 H_INIT values match FIPS 180-4 ✓")

    return all_ok


def generate_nist_test_cases() -> list:
    """Generate test cases from NIST CAVP vectors."""
    test_cases = []

    for name, msg_hex, expected_hash in NIST_TEST_VECTORS:
        if msg_hex == "GENERATE_1M_A":
            # Skip the 1 million 'a' test for normal runs (too slow for VHDL sim)
            continue

        data = bytes.fromhex(msg_hex)
        padded = pad_message(data)
        blocks = [padded[j:j+128] for j in range(0, len(padded), 128)]

        # Verify against Python hashlib
        py_hash = sha384_python(data)
        if py_hash != expected_hash:
            print(f"  WARNING: {name} Python hash mismatch with NIST!")
            print(f"    Python:   {py_hash}")
            print(f"    Expected: {expected_hash}")

        test_cases.append((name, blocks, expected_hash))

    return test_cases


def generate_boundary_test_cases() -> list:
    """Generate test cases for boundary lengths."""
    test_cases = []

    for length in BOUNDARY_LENGTHS:
        # Use deterministic data for reproducibility
        data = bytes([i % 256 for i in range(length)])
        py_hash = sha384_python(data)
        padded = pad_message(data)
        blocks = [padded[j:j+128] for j in range(0, len(padded), 128)]

        name = f"boundary_{length}b"
        test_cases.append((name, blocks, py_hash))

    return test_cases


def generate_multiblock_stress_test() -> list:
    """Generate a long multi-block message test (10+ blocks)."""
    test_cases = []

    # 10 blocks = 1280 bytes of data (needs 11 blocks with padding)
    # Use 1200 bytes to get 10 blocks after padding
    for num_blocks in [5, 10, 15]:
        # Calculate length to get target number of blocks
        # Each block is 128 bytes, padding takes ~17 bytes minimum
        length = (num_blocks - 1) * 128 + 64  # Roughly num_blocks blocks

        # Deterministic pattern
        data = bytes([(i * 7 + 13) % 256 for i in range(length)])
        py_hash = sha384_python(data)
        padded = pad_message(data)
        blocks = [padded[j:j+128] for j in range(0, len(padded), 128)]

        name = f"multiblock_{len(blocks)}blk_{length}b"
        test_cases.append((name, blocks, py_hash))

    return test_cases


def cross_verify_with_openssl(test_cases: list) -> bool:
    """Cross-verify test cases with OpenSSL."""
    print("\n" + "=" * 60)
    print("CROSS-VERIFYING WITH OPENSSL")
    print("=" * 60)

    if not shutil.which("openssl"):
        print("  OpenSSL not found in PATH - skipping cross-verification")
        return True

    all_ok = True
    checked = 0
    for name, blocks, expected_hash in test_cases[:10]:  # Check first 10
        # Reconstruct original data from blocks (remove padding)
        # For deterministic tests, we can just use the name to figure out length
        if name.startswith("boundary_"):
            length = int(name.split("_")[1].replace("b", ""))
            data = bytes([i % 256 for i in range(length)])
        elif name.startswith("multiblock_"):
            # Extract length from name
            parts = name.split("_")
            length = int(parts[2].replace("b", ""))
            data = bytes([(i * 7 + 13) % 256 for i in range(length)])
        elif name.startswith("NIST_"):
            # Find in NIST vectors
            for nist_name, msg_hex, _ in NIST_TEST_VECTORS:
                if nist_name == name and msg_hex != "GENERATE_1M_A":
                    data = bytes.fromhex(msg_hex)
                    break
            else:
                continue
        else:
            continue  # Skip random tests for OpenSSL verification

        openssl_hash = sha384_openssl(data)
        if openssl_hash:
            checked += 1
            if openssl_hash != expected_hash:
                print(f"  {name}: OpenSSL MISMATCH!")
                print(f"    Expected: {expected_hash}")
                print(f"    OpenSSL:  {openssl_hash}")
                all_ok = False

    if checked > 0:
        print(f"  Verified {checked} test cases against OpenSSL ✓")
    return all_ok


def main():
    parser = argparse.ArgumentParser(description="Compare SHA-384 implementations")
    parser.add_argument("--count", type=int, default=5, help="Number of random tests")
    parser.add_argument("--max-len", type=int, default=200, help="Max message length in bytes")
    parser.add_argument("--seed", type=int, default=None, help="Random seed")
    parser.add_argument("--skip-vhdl", action="store_true", help="Skip VHDL tests (verify only)")
    parser.add_argument("--quick", action="store_true", help="Quick mode: fewer tests")
    args = parser.parse_args()

    if args.seed is not None:
        random.seed(args.seed)

    project_dir = Path(__file__).parent
    all_ok = True

    print("=" * 60)
    print("SHA-384 COMPREHENSIVE TEST SUITE")
    print("=" * 60)

    # ==========================================================================
    # Phase 1: Verify constants against FIPS 180-4
    # ==========================================================================
    if not verify_k_constants(project_dir):
        all_ok = False
    if not verify_h_init(project_dir):
        all_ok = False

    # ==========================================================================
    # Phase 2: Generate test cases
    # ==========================================================================
    print("\n" + "=" * 60)
    print("GENERATING TEST CASES")
    print("=" * 60)

    test_cases = []

    # NIST CAVP vectors (independent reference)
    print("\n  Adding NIST CAVP test vectors...")
    nist_cases = generate_nist_test_cases()
    test_cases.extend(nist_cases)
    print(f"    {len(nist_cases)} NIST test vectors")

    # Boundary tests
    print("  Adding boundary length tests...")
    boundary_cases = generate_boundary_test_cases()
    test_cases.extend(boundary_cases)
    print(f"    {len(boundary_cases)} boundary tests")

    # Multi-block stress tests
    if not args.quick:
        print("  Adding multi-block stress tests...")
        multiblock_cases = generate_multiblock_stress_test()
        test_cases.extend(multiblock_cases)
        print(f"    {len(multiblock_cases)} multi-block tests")

    # Random tests
    random_count = 3 if args.quick else args.count
    print(f"  Adding {random_count} random test cases...")
    for i in range(random_count):
        length = random.randint(0, args.max_len)
        data = os.urandom(length)
        py_hash = sha384_python(data)
        padded = pad_message(data)
        blocks = [padded[j:j+128] for j in range(0, len(padded), 128)]
        test_cases.append((f"random_{length}b", blocks, py_hash))

    print(f"\n  Total: {len(test_cases)} test cases")

    # ==========================================================================
    # Phase 3: Cross-verify with OpenSSL
    # ==========================================================================
    if not cross_verify_with_openssl(test_cases):
        all_ok = False

    # ==========================================================================
    # Phase 4: Run VHDL tests
    # ==========================================================================
    if args.skip_vhdl:
        print("\n  Skipping VHDL tests (--skip-vhdl)")
    else:
        # Write test vectors
        vectors_file = project_dir / "test_vectors.txt"
        write_test_vectors(vectors_file, test_cases)
        print(f"\n  Wrote {len(test_cases)} test vectors to {vectors_file}")

        # Check if file-based testbenches exist
        baseline_tb = project_dir / "sha384_file_tb.vhd"
        fast_tb = project_dir / "sha384_fast_file_tb.vhd"
        fast8_tb = project_dir / "sha384_fast8_file_tb.vhd"
        pipeline_tb = project_dir / "sha384_pipeline_file_tb.vhd"

        if not baseline_tb.exists() or not fast_tb.exists():
            print("\n  File-based testbenches not found!")
            return 1

        # Run tests
        print("\n" + "=" * 60)
        print("RUNNING VHDL SIMULATIONS")
        print("=" * 60)

        print("\n  Running baseline sha384...")
        baseline_results = run_vhdl_test(project_dir, "baseline")
        if "error" in baseline_results:
            print(f"    ERROR: {baseline_results['error']}")
            all_ok = False
        else:
            print(f"    Passed: {baseline_results['passed']}/{len(test_cases)}")

        print("\n  Running optimized sha384_fast (4x)...")
        fast_results = run_vhdl_test(project_dir, "fast")
        if "error" in fast_results:
            print(f"    ERROR: {fast_results['error']}")
            all_ok = False
        else:
            print(f"    Passed: {fast_results['passed']}/{len(test_cases)}")

        fast8_results = {"hashes": [], "passed": 0}
        if fast8_tb.exists():
            print("\n  Running optimized sha384_fast8 (8x)...")
            fast8_results = run_vhdl_test(project_dir, "fast8")
            if "error" in fast8_results:
                print(f"    ERROR: {fast8_results['error']}")
                all_ok = False
            else:
                print(f"    Passed: {fast8_results['passed']}/{len(test_cases)}")

        pipeline_results = {"hashes": [], "passed": 0}
        if pipeline_tb.exists():
            print("\n  Running pipelined sha384_pipeline...")
            pipeline_results = run_vhdl_test(project_dir, "pipeline")
            if "error" in pipeline_results:
                print(f"    ERROR: {pipeline_results['error']}")
                all_ok = False
            else:
                print(f"    Passed: {pipeline_results['passed']}/{len(test_cases)}")

        multi_tb = project_dir / "sha384_multi_file_tb.vhd"
        multi_results = {"hashes": [], "passed": 0}
        if multi_tb.exists():
            print("\n  Running multi-core sha384_multi (4 cores)...")
            multi_results = run_vhdl_test(project_dir, "multi")
            if "error" in multi_results:
                print(f"    ERROR: {multi_results['error']}")
                all_ok = False
            else:
                print(f"    Passed: {multi_results['passed']}/{len(test_cases)}")

        # Detailed comparison
        print("\n" + "=" * 60)
        print("DETAILED RESULTS")
        print("=" * 60)

        for i, (name, _, expected_hash) in enumerate(test_cases):
            baseline_hash = baseline_results['hashes'][i] if i < len(baseline_results.get('hashes', [])) else None
            fast_hash = fast_results['hashes'][i] if i < len(fast_results.get('hashes', [])) else None
            fast8_hash = fast8_results['hashes'][i] if i < len(fast8_results.get('hashes', [])) else None
            pipeline_hash = pipeline_results['hashes'][i] if i < len(pipeline_results.get('hashes', [])) else None
            multi_hash = multi_results['hashes'][i] if i < len(multi_results.get('hashes', [])) else None

            baseline_ok = baseline_hash == expected_hash
            fast_ok = fast_hash == expected_hash
            fast8_ok = fast8_hash == expected_hash if fast8_tb.exists() else True
            pipeline_ok = pipeline_hash == expected_hash if pipeline_tb.exists() else True
            multi_ok = multi_hash == expected_hash if multi_tb.exists() else True

            if not (baseline_ok and fast_ok and fast8_ok and pipeline_ok and multi_ok):
                all_ok = False
                print(f"\n  {name}: MISMATCH")
                print(f"    Expected: {expected_hash}")
                if not baseline_ok:
                    print(f"    Baseline: {baseline_hash}")
                if not fast_ok:
                    print(f"    Fast4x:   {fast_hash}")
                if not fast8_ok:
                    print(f"    Fast8x:   {fast8_hash}")
                if not pipeline_ok:
                    print(f"    Pipeline: {pipeline_hash}")
                if not multi_ok:
                    print(f"    Multi:    {multi_hash}")

    # ==========================================================================
    # Final Summary
    # ==========================================================================
    print("\n" + "=" * 60)
    print("FINAL SUMMARY")
    print("=" * 60)

    if all_ok:
        print("\n  ✓ All tests passed!")
        print("  ✓ K constants verified against FIPS 180-4")
        print("  ✓ H_INIT values verified against FIPS 180-4")
        print("  ✓ NIST CAVP vectors passed")
        print("  ✓ Boundary length tests passed")
        if not args.quick:
            print("  ✓ Multi-block stress tests passed")
        print("  ✓ Random tests passed")
        if shutil.which("openssl"):
            print("  ✓ OpenSSL cross-verification passed")
        if not args.skip_vhdl:
            print("  ✓ All 5 VHDL implementations verified (baseline, fast, fast8, pipeline, multi)")
        return 0
    else:
        print("\n  ✗ Some tests FAILED!")
        return 1


if __name__ == "__main__":
    sys.exit(main())
